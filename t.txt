@app.route("/predict-stock", methods=['POST'])
def predict_stock():
    data = request.get_json()
    ticker = data['ticker']

    df = yf.download(ticker, start='2019-01-01', end=datetime.today().strftime('%Y-%m-%d'))
    if df.empty:
        return jsonify({'error': 'Failed to fetch stock data.'}), 400

    nifty = yf.download("^NSEI", start='2019-01-01', end=datetime.today().strftime('%Y-%m-%d'))[['Close']].rename(columns={'Close': 'NIFTY_Close'})
    sensex = yf.download("^BSESN", start='2019-01-01', end=datetime.today().strftime('%Y-%m-%d'))[['Close']].rename(columns={'Close': 'SENSEX_Close'})

    df = df.merge(nifty, left_index=True, right_index=True)
    df = df.merge(sensex, left_index=True, right_index=True)

    df = df[['Close', 'Open', 'High', 'Low', 'Volume', 'NIFTY_Close', 'SENSEX_Close']]

    scaler = MinMaxScaler(feature_range=(-1, 1))
    df_scaled = scaler.fit_transform(df)

    def create_sequences(data, seq_length=20):
        sequences = []
        for i in range(len(data) - seq_length):
            sequences.append(data[i: i + seq_length + 1])
        return np.array(sequences)

    sequences = create_sequences(df_scaled, 20)

    X_test = sequences[:, :-1, :]
    y_test = sequences[:, -1, 0]

    model = Sequential()
    model.add(LSTM(128, return_sequences=True, activation='relu', input_shape=(X_test.shape[1], X_test.shape[2])))
    model.add(LSTM(64, activation='relu'))
    model.add(Dense(39, activation='relu'))
    model.add(BatchNormalization())
    model.add(Dense(1))

    model.compile(optimizer=Adam(1e-6), loss=Huber(), metrics=['mse'])

    model.fit(X_test, y_test, epochs=5, batch_size=32, verbose=0)

    predictions = model.predict(X_test).reshape(-1, 1)
    predictions_unscaled = scaler.inverse_transform(np.hstack((predictions, np.zeros((len(predictions), 6)))))[:, 0]

    historical_data = [{
        'date': str(df.index[-len(predictions_unscaled)+i].date()),
        'price': float(pred)
    } for i, pred in enumerate(predictions_unscaled)]

    result = {
        'stock': ticker,
        'predictedPrice': round(predictions_unscaled[-1], 2),
        'historicalData': historical_data
    }

    return jsonify(result)

1. Update your API response in run_lstm_prediction
Add these lines after you compute valid['Predictions'] and before returning the result:

# ...existing code...

    # Prepare actual vs predicted for validation/test period
    actual_vs_predicted = [
        {
            'date': str(valid.index[i].date()),
            'actual': float(valid['Close'].iloc[i]),
            'predicted': float(valid['Predictions'].iloc[i])
        }
        for i in range(len(valid))
    ]

    # Final result JSON
    result = {
        'stock': str(ticker),
        'predictedPrice': float(round(predictions_unscaled[-1], 2)),
        'historicalData': [
            {
                'date': str(df.index[-len(predictions_unscaled) + i].date()),
                'price': float(pred)
            } for i, pred in enumerate(predictions_unscaled)
        ],
        'futurePrices': [float(x) for x in future_prices.tolist()],
        'futureDates': [str(x) for x in future_dates.strftime('%Y-%m-%d').tolist()],
        'buySignals': {
            "points": [float(x) for x in buy_signals["points"]],
            "reasons": [str(r) for r in buy_signals["reasons"]]
        },
        'buyIndices': [int(x) for x in buy_indices],
        'actualVsPredicted': actual_vs_predicted  # <-- add this line
    }

    return jsonify(result)
# ...existing code...

2. Update your frontend (JS) to plot both lines
In your predict.js, update the chart rendering logic to use the new actualVsPredicted array:
function renderPredictionChart(prediction) {
    // ...existing code...

    // Plot actual vs predicted for validation/test period
    if (prediction.actualVsPredicted && Array.isArray(prediction.actualVsPredicted)) {
        const validDates = prediction.actualVsPredicted.map(d => d.date);
        const actualVals = prediction.actualVsPredicted.map(d => d.actual);
        const predictedVals = prediction.actualVsPredicted.map(d => d.predicted);

        const traceActual = {
            x: validDates,
            y: actualVals,
            mode: 'lines',
            name: 'Actual Price',
            line: { color: 'green', width: 2 }
        };

        const tracePredicted = {
            x: validDates,
            y: predictedVals,
            mode: 'lines',
            name: 'Predicted Price',
            line: { color: 'red', width: 2, dash: 'dot' }
        };

        // Add these traces to your Plotly data array
        data.push(traceActual, tracePredicted);
    }

    // ...existing code...
}


@app.route('/api/fundamentals')
def api_fundamentals():
    symbol = request.args.get('symbol')
    if not symbol:
        return jsonify({'error': 'No symbol provided'}), 400
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        history = ticker.history(period="1y")
        if history.empty:
            return jsonify({'error': f'No data found for symbol: {symbol}'}), 404
        # ... rest of your code ...
        # You can adjust which fields you want to send
        data = {
            'pe': info.get('trailingPE'),
            'pb': info.get('priceToBook'),
            'ps': info.get('priceToSalesTrailing12Months'),
            'divYield': (info.get('dividendYield') or 0) * 100,
            'roe': info.get('returnOnEquity') * 100 if info.get('returnOnEquity') is not None else None,
            'roa': info.get('returnOnAssets') * 100 if info.get('returnOnAssets') is not None else None,
            'grossMargin': info.get('grossMargins') * 100 if info.get('grossMargins') is not None else None,
            'opMargin': info.get('operatingMargins') * 100 if info.get('operatingMargins') is not None else None,
            'currentRatio': info.get('currentRatio'),
            'quickRatio': info.get('quickRatio'),
            'debtEquity': info.get('debtToEquity'),
            'intCoverage': info.get('ebitda') / info.get('interestExpense') if info.get('ebitda') and info.get('interestExpense') else None,
            'history': ticker.history(period="1y").reset_index().to_dict(orient='records')
        }
        return jsonify(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 500




  document.addEventListener("DOMContentLoaded", function() {
    const darkModeToggle = document.getElementById("darkModeToggle");
    const toggleIcon = document.querySelector('.toggle-circle .toggle-icon');

    function updateToggleIcon() {
        if (darkModeToggle.checked) {
            toggleIcon.innerHTML = '&#9790;'; // Moon
        } else {
            toggleIcon.innerHTML = '&#9728;'; // Sun
        }
    }

    // Initial state
    

    // Set the toggle to checked (on) by default
    darkModeToggle.checked = true;
    updateToggleIcon();
    // Apply dark mode on page load
    document.body.classList.add("dark-mode");

    darkModeToggle.addEventListener("change", function() {
      document.body.classList.toggle("dark-mode");
      if (typeof updateChartColors === "function") updateChartColors(this.checked);
      updateToggleIcon();
    });
});      

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 25px;
}
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}
.slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 25px;
}
.toggle-circle {
    position: absolute;
    left: 4px;
    bottom: 3px;
    width: 18px;
    height: 18px;
    background: #fff;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.4s;
    z-index: 2;
    font-size: 14px;
}
.toggle-icon {
    transition: color 0.4s, content 0.4s;
    color: #FFD600; /* Sun color */
}
input:checked + .slider {
    background-color: #4a8fdf;
}
input:checked + .slider .toggle-circle {
    transform: translateX(24px);
}
input:checked + .slider .toggle-icon {
    color: #4a8fdf; /* Moon color */
    /* Use content swap via JS for moon icon */
}